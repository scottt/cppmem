(*Generated by Lem from ../axiomatic/ntc/operational/opsem.lem.*)
open Nat_num

open Sum

type 'a set = 'a Pset.set

open Cmm

(* Auxilaries *)

(*val find_or_default: forall 'key 'a. 'key ->'a -> Pmap.map 'key 'a -> 'a*)
let find_or_default key default map =  
(if ( Pmap.mem key map) then Pmap.find key map
  else
    default)
    
(*val integer_to_string: num -> string*)
let rec integer_to_string i = 
  ((match i with
       0 -> "0"
     | n -> (let j0 = ( Nat_num.(-) n 1) in "S" ^ (integer_to_string j0))
   ))

(* Programs *)

type variable = string
type register = num

type int_exp = 
  | ConstI of num
  | Var of register
  | Plus of int_exp * int_exp
  
type bool_exp = 
  | ConstB of bool
  | Equals of int_exp * int_exp
  | Greater of int_exp * int_exp
  | Not of bool_exp
  | And of bool_exp * bool_exp
  
type node = num
  
type statement = 
  | Load of Cmm.memory_order * register * variable
  | Store of Cmm.memory_order * variable * int_exp
  | Assert of bool_exp
  | CreateThread of node
  | JoinThread of node
  
type program = 
{ start_node: node;
   edges: (node, ( (statement * node)set)) Pmap.map;
   end_node: node;
}

(*val get_edges: program -> node -> set (statement * node)*)
let get_edges program node =  
 ( 
  find_or_default node 
  (Pset.from_list Pervasives.compare []) program.edges)

(* Actions *)

type aid = num
type tid = num

type action = 
  | Load2 of aid * tid * Cmm.memory_order * register * variable * num
  | Store2 of aid * tid * Cmm.memory_order * variable * num
  | Assert2 of aid * tid * bool_exp
  | CreateThread2 of aid * tid * node
  | JoinThread2 of aid * tid * node
  | CommitRead
  | CommitWrite

(* Memory *)

type memory = (variable, ( (num * Cmm.action)list)) Pmap.map

(*val initial_memory: memory*)
let initial_memory = (Pmap.empty Pervasives.compare)

(*val get_memory_entries: memory -> variable -> list (num * Cmm.action)*)
let get_memory_entries memory var =  
 ( 
  find_or_default var [] memory)

(*val update_memory: memory -> variable -> num -> Cmm.action -> memory*)
let update_memory memory var value action =  
 (let old = ( find_or_default var [] memory) in Pmap.add var ((value, action) ::old) memory)

type registry = (register, num) Pmap.map

(*val initial_registry: registry*)
let initial_registry = (Pmap.empty Pervasives.compare)

(*val eval_int: registry -> int_exp -> num*)
let rec eval_int registry exp =  
 ((match exp with
  | ConstI( n)     -> n
  | Var( register) -> find_or_default register 0 registry
  | Plus( e1, e2)   -> Nat_num.(+)(eval_int registry e1) (eval_int registry e2)
  ))
  
(*val eval_bool: registry -> bool_exp -> bool*)
let rec eval_bool r e =  
((match e with
  | ConstB( b)      -> b
  | Equals( e1, e2)  -> (eval_int r e1) = (eval_int r e2)
  | Greater( e1, e2) -> Nat_num.(>)(eval_int r e1) (eval_int r e2)
  | Not( e1)        -> not (eval_bool r e1)
  | And( e1, e2)     -> (eval_bool r e1) && (eval_bool r e2)
  ))
    
(*val update_registry: registry -> register -> num -> registry*)
let update_registry r v n = ( Pmap.add v n r)
  
(* Modification order *)

type mo_memory = (string, ( Cmm.action list)) Pmap.map

(*val update_mo: mo_memory -> string -> Cmm.action -> mo_memory*)
let update_mo memory var action =  
 (let current = ( find_or_default var [] memory) in Pmap.add var (action ::current) memory)

(* States *)

type threadstate = 
{ current_node: node;
   tid: num;
   previous_cmm_action: Cmm.action option;
   is_new: bool;
}

type state = 
{ memory  : memory;
   registry: registry;      
   running_threads: (num, threadstate) Pmap.map;
   threads : num set;
   max_tid : num;
   max_aid : num;
   actions : Cmm.action set;
   lk      : (string,  Cmm.location_kind) Pmap.map;
   sb      : (Cmm.action * Cmm.action) set;
   asw     : (Cmm.action * Cmm.action) set;
   rf      : (Cmm.action * Cmm.action) set;
   mo      : mo_memory;
   lo      : (action * action) set;
}

(*val initial_threadstate: program -> threadstate*)
let initial_threadstate p =
({ current_node = p.start_node;
   tid = 0;
   previous_cmm_action = ( None);
   is_new = true;
})

(*val initial_state: program -> state*)
let initial_state p =
({ memory = initial_memory;
   registry = initial_registry;
   running_threads = ( Pmap.add 0 (initial_threadstate p) (Pmap.empty Pervasives.compare));  
   threads =(Pset.from_list Pervasives.compare [0]);
   max_tid = 1;
   max_aid = 0;
   actions =(Pset.from_list Pervasives.compare []);
   lk = (Pmap.empty Pervasives.compare);
   sb =(Pset.from_list Pervasives.compare []);
   asw =(Pset.from_list Pervasives.compare []);
   rf =(Pset.from_list Pervasives.compare []);
   mo = (Pmap.empty Pervasives.compare);
   lo =(Pset.from_list Pervasives.compare []);
})

(* To Cmm *)

(*val get_cvalue: num -> Cmm.cvalue*)
let get_cvalue n = ( Rigid( (Concrete( n))))

(*val get_cvalue2: string -> Cmm.cvalue*)
let get_cvalue2 s = ( Rigid( (Symbolic( s))))

(*val default_loc: Cmm.location_kind*)
let default_loc = ( Cmm.Atomic)

(*val lookup_location: list (string * Cmm.location_kind) -> Cmm.cvalue -> Cmm.location_kind*)
let rec lookup_location l c =  
 ((match l with
  | [] -> default_loc
  | (s, loc)::t -> (match c with 
                   | Rigid( r) -> (match r with 
                                | Concrete( _) -> default_loc
                                | Symbolic( s2) -> (if s = s2 then loc else lookup_location t c)
                                )
                   | Flexible( _) -> default_loc
                   )
  ))
  
(*val to_cmm_load: num -> num -> Cmm.memory_order -> string -> num -> Cmm.action*)
let to_cmm_load aid tid mo var value =  
(
  Cmm.Load( (integer_to_string aid), (get_cvalue tid), mo, (get_cvalue2 var), (get_cvalue value)))
  
(*val to_cmm_store: num -> num -> Cmm.memory_order -> string -> num -> Cmm.action*)
let to_cmm_store aid tid mo var value =  
(
  Cmm.Store( (integer_to_string aid), (get_cvalue tid), mo, (get_cvalue2 var), (get_cvalue value)))
  
(*val to_cmm_action: action -> option Cmm.action*)
let to_cmm_action action =  
 ((match action with 
  | Load2( aid, tid, mo, _, var, value) -> Some( (to_cmm_load aid tid mo var value))
  | Store2( aid, tid, mo, var, value) -> Some( (to_cmm_store aid tid mo var value))
  | Assert2( _, _, _) -> None
  | CreateThread2( _, _, _) -> None
  | JoinThread2( _, _, _) -> None
  | CommitRead -> None
  | CommitWrite -> None
  ))
  
(*
val to_cmm_relation: set (action * action) -> set (Cmm.action * Cmm.action)
let to_cmm_relation rel = 
  Pervasives.bigunion
  { match to_cmm_action a1 with
    | None -> {}
    | Some b1 -> match to_cmm_action a2 with
      | None -> {} 
      | Some b2 -> {(b1, b2)}
      end
    end
  | forall ((a1, a2) IN rel) | true }
*)

(*val to_pre_execution: state -> Cmm.pre_execution*)
let to_pre_execution state =
({
   Cmm.actions = state.actions;
   Cmm.threads = (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold (fun t x2 -> if true then Pset.add (get_cvalue t) x2 else x2)
   state.threads x2);
   Cmm.lk      = (fun x -> lookup_location ( Pmap.bindings state.lk) x);
   Cmm.sb      = ( tc state.sb);
   Cmm.asw     = ( tc state.asw);
   Cmm.dd      =(Pset.from_list Pervasives.compare []);
})

(*val list_to_relation: forall 'a. list 'a -> set ('a * 'a)*)
let rec list_to_relation list =  
 ((match list with 
  | h1::(h2::t) -> Pset.add (h2, h1) (list_to_relation (h2 ::t))
  | _ ->Pset.from_list Pervasives.compare []
  ))

(*val to_execution_witness: state -> Cmm.execution_witness*)
let to_execution_witness state =
({
   Cmm.rf  = state.rf;
   Cmm.mo  = ( Pset.bigunion compare (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun(key, l) x2 ->
    if true then Pset.add ( tc (list_to_relation l)) x2 else x2)
   ( Pset.from_list compare ( Pmap.bindings state.mo)) x2));
   Cmm.sc  =(Pset.from_list Pervasives.compare []);
   Cmm.lo  =(Pset.from_list Pervasives.compare []);
   Cmm.ao  =(Pset.from_list Pervasives.compare []);
   Cmm.tot =(Pset.from_list Pervasives.compare []);
})

(*val isAllowed: Cmm.memory_model -> Cmm.protocol_t -> state -> bool*)
let isAllowed m protocol s =  
(let xo = ( to_pre_execution s) in
  let xw = ( to_execution_witness s) in
  let rl = (m.relation_calculation xo xw) in
  let completeEx = (xo, xw, rl) in
  Cmm.apply_tree m.consistent completeEx && (protocol completeEx && Cmm.each_empty m.undefined completeEx))
  
(*val isAllowed_relacq : state -> bool*)
let isAllowed_relacq s = ( isAllowed Cmm.release_acquire_memory_model Cmm.release_acquire_protocol s)

(* Transitions *)

type transition = 
{ action: action;
   state: state;
}

(*val execute_load_aux: (Cmm.memory_order * register * variable * num * Cmm.action) -> threadstate -> state -> transition*)
let execute_load_aux (mo, reg, var, value, write_action) threadstate state =   
 (let action = ( Load2( state.max_aid, threadstate.tid, mo, reg, var, value)) in
   let cmm_action = ( to_cmm_load state.max_aid threadstate.tid mo var value) in
   let new_rf = ( Pset.add (write_action, cmm_action) state.rf) in
   let new_state = ({ state with
                      registry = update_registry state.registry reg value;
                      rf = new_rf; }) in
   { action = action; state = new_state })

(*val execute_load: (Cmm.memory_order * register * variable) -> threadstate -> state -> set transition*)
let execute_load (mo, reg, var) threadstate state =   
 (let memory_entries = ( get_memory_entries state.memory var) in
   let possible_reads = ((match mo with
                         | Cmm.NA -> ((match memory_entries with 
                                      | [] ->
  Pset.from_list Pervasives.compare []
                                      | h::_ ->
  Pset.from_list Pervasives.compare [h]
                                      ))
                         | _ -> Pset.from_list compare memory_entries
                         )) in   
   let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun(value, action) x2 ->
    if true then
      Pset.add
        (execute_load_aux (mo, reg, var, value, action) threadstate state) 
      x2 else x2) possible_reads x2)

(*val execute_store: (Cmm.memory_order * variable * int_exp) -> threadstate -> state -> set transition*)
let execute_store (mo, var, exp) threadstate state =   
 (let value = ( eval_int state.registry exp) in
   let action = ( Store2( state.max_aid, threadstate.tid, mo, var, value)) in
   let cmm_action = ( to_cmm_store state.max_aid threadstate.tid mo var value) in
   let location_kind = (if mo = NA then Non_Atomic else Atomic) in
   let new_mo = ( update_mo state.mo var cmm_action) in
   let new_state = ({ state with
                      memory = update_memory state.memory var value cmm_action;
                      lk = Pmap.add var location_kind state.lk;
                      mo = new_mo }) in 
  Pset.from_list Pervasives.compare [{ action = action; state = new_state }])
     
(*val execute_assert: bool_exp -> threadstate -> state -> set transition*)
let execute_assert exp threadstate state =   
 (if eval_bool state.registry exp then 
     let action = ( Assert2( state.max_aid, threadstate.tid, exp)) in 
  Pset.from_list Pervasives.compare [{ action = action; state = state }]
   else Pset.from_list Pervasives.compare [])

(*val execute_create_thread: node -> threadstate -> state -> set transition*)
let execute_create_thread target threadstate state =   
 (let action = ( CreateThread2( state.max_aid, threadstate.tid, target)) in
   let target_threadstate = ({ current_node = target;
                               tid = state.max_tid;
                               previous_cmm_action = threadstate.previous_cmm_action;
                               is_new = true; }) in
   let new_state = ({ state with
                      max_tid = Nat_num.(+)state.max_tid 1;
                      threads = Pset.add state.max_tid state.threads;
                      running_threads = Pmap.add state.max_tid target_threadstate state.running_threads; }) in 
  Pset.from_list Pervasives.compare [{ action = action; state = new_state }])

(*val execute_join_thread: node -> threadstate -> state -> set transition*)
let execute_join_thread target threadstate state =   
 (let threads_at_target = (let x2 = 
  ([]) in  List.fold_right
   (fun(i, t) x2 -> if t.current_node = target then t :: x2 else x2)
   ( Pmap.bindings state.running_threads) x2) in
   (match threads_at_target with
   | [] ->Pset.from_list Pervasives.compare []
   | target_thread::_ -> 
     let action = ( JoinThread2( state.max_aid, threadstate.tid, target)) in
     let new_state = ({ state with
                        running_threads = Pmap.remove target_thread.tid state.running_threads; }) in 
  Pset.from_list Pervasives.compare [{ action = action; state = new_state }]
   ))
   
(*val execute_statement_aux: node -> threadstate -> transition -> transition*)
let execute_statement_aux new_node threadstate transition =   
(let action = (transition.action) in
   let state = (transition.state) in
   let cmm_action_option = ( to_cmm_action action) in
   let new_previous_action = ((match cmm_action_option with | None -> threadstate.previous_cmm_action | Some( a) -> Some( a) )) in
   let new_threadstate = ({ threadstate with
                            current_node = new_node;
                            previous_cmm_action = new_previous_action; 
                            is_new = false; }) in
   let new_running_threads = ( Pmap.add threadstate.tid new_threadstate state.running_threads) in
   let new_state = ({ state with
                      max_aid = Nat_num.(+)state.max_aid 1;
                      running_threads = new_running_threads; }) in 
   let new_state2 = ((match cmm_action_option with
     | None -> new_state
     | Some( cmm_action) ->    
       let new_actions = ( Pset.add cmm_action state.actions) in
       let new_sb = (if threadstate.is_new then
                       state.sb
                     else
                       (match threadstate.previous_cmm_action with
                       | None -> state.sb
                       | Some( b) -> Pset.add (b, cmm_action) state.sb
                       )) in
       let new_asw = (if threadstate.is_new then
                        (match threadstate.previous_cmm_action with
                        | None -> state.asw
                        | Some( b) -> Pset.add (b, cmm_action) state.asw
                        )
                      else
                        state.asw) in
       { new_state with
          actions = new_actions;
          sb = new_sb;
          asw = new_asw; }
     )) in  
   { action = action; state = new_state2 })

(*val execute_statement: statement -> node -> threadstate -> state -> set transition*)
let execute_statement statement new_node threadstate state =  
(let transitions =    
 ((match statement with
    | Load( mo, r, v) -> execute_load (mo, r, v) threadstate state
    | Store( mo, v, e) -> execute_store (mo, v, e) threadstate state
    | Assert( e) -> execute_assert e threadstate state
    | CreateThread( target) -> execute_create_thread target threadstate state
    | JoinThread( target) -> execute_join_thread target threadstate state
    ))
  in Pset.map compare (execute_statement_aux new_node threadstate) transitions)  
  
(*val all_transitions_aux: program -> threadstate -> state -> set transition*)
let all_transitions_aux program threadstate state =  
 (let edges = ( get_edges program threadstate.current_node) in Pset.bigunion compare (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun(statement, new_node) x2 ->
    if true then
      Pset.add (execute_statement statement new_node threadstate state) x2
    else x2) edges x2))  

(*val all_transitions: program -> state -> set transition*)
let all_transitions program state =  
 (let current_threads = (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold (fun(key, item) x2 -> if true then Pset.add item x2 else x2)
   ( Pset.from_list compare ( Pmap.bindings state.running_threads)) x2) in Pset.bigunion compare (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun threadstate x2 ->
    if true then Pset.add (all_transitions_aux program threadstate state) x2
    else x2) current_threads x2))

(*val allowed_transitions: program -> state -> set transition*)
let allowed_transitions program state =  
 (let transitions = ( all_transitions program state) in
  transitions)
  (*
  Set.filter (fun transition -> isAllowed_relacq transition.state) transitions *)

