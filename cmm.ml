(*Generated by Lem from ../axiomatic/ntc/cmm.lem.*)
open Nat_num

open Sum

type 'a set = 'a Pset.set

(*========================================================================*)
(*                                                                        *)
(*             cppmem model exploration tool                              *)
(*                                                                        *)
(*                    Mark Batty                                          *)
(*                    Scott Owens                                         *)
(*                    Jean Pichon                                         *)
(*                    Susmit Sarkar                                       *)
(*                    Peter Sewell                                        *)
(*                                                                        *)
(*  This file is copyright 2011, 2012 by the above authors.               *)
(*                                                                        *)
(*  Redistribution and use in source and binary forms, with or without    *)
(*  modification, are permitted provided that the following conditions    *)
(*  are met:                                                              *)
(*  1. Redistributions of source code must retain the above copyright     *)
(*  notice, this list of conditions and the following disclaimer.         *)
(*  2. Redistributions in binary form must reproduce the above copyright  *)
(*  notice, this list of conditions and the following disclaimer in the   *)
(*  documentation and/or other materials provided with the distribution.  *)
(*  3. The names of the authors may not be used to endorse or promote     *)
(*  products derived from this software without specific prior written    *)
(*  permission.                                                           *)
(*                                                                        *)
(*  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS    *)
(*  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED     *)
(*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    *)
(*  ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY       *)
(*  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    *)
(*  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE     *)
(*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS         *)
(*  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHE   *)
(*  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR       *)
(*  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN   *)
(*  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                         *)
(*========================================================================*)

(* emacs fontification -*-caml-*- *)

(*

Log:

20/03/13 - a savage and hasty tidy, following r10282

--- Introduction ---

This file contains a mathematical version of the relaxed memory model
of C11 and C++11, written in the specification language of Lem. Lem
can compile it to Ocaml, HOL, Isabelle or Latex. The basic model is
faithful to the intent of the 2011 standard and included here in
full. In addition, there are several simplified models that either remove
redundant concepts or provide simplifications for programs that
restrict the input language of programs.

There are lots of definitions that make up the models. To help you
navigate them, the following table of contents (with unique key
phrases) can be used to search the document. Where appropriate, there
are comments describing or explaining the definitions. These are
especially important for the top-level definitions of the simplified models.

--- Contents ---


1 - Relational definitions

2 - Type definitions and projections

  - 2.1 - Action and location types

  - 2.2 - Execution records

  - 2.3 - Projection functions 

  - 2.4 - Location kinds

  - 3.1  - Well formed action

  - 3.2  - Well formed threads

4 - Memory_Model simplified, single thread, no atomics

5 - Memory_Model simplified, multi-thread, no atomics, yes locks

6 - relaxed - memory_model simplified for programs without sc,
consumes, release or acquire

7 - release acquire - memory_model simplified for programs without sc,
consumes or relaxed

8 - release_acquire_relaxed - memory_model simplified for programs without sc,
consumes or relaxed

9 - release_acquire_fenced

10 - sc, no sc fences

11 - sc_fences, no consume

12 - with consume

13 - the standard model

14 - Meta-theory

15 - release acquire, no locks - memory_model simplified for programs without sc,
consumes, relaxed or locks

*)





(*************************************************** *)
(* 1 - Relational definitions *)
(*************************************************** *)


let irrefl ord = ( Pset.for_all (fun (x,y) -> not (x = y)) ord)

let trans ord = ( Pset.for_all
   (fun (w,x) -> Pset.for_all
                   (fun (y,z) -> ( not (x = y) || Pset.mem (w,z) ord)) 
                 ord) ord)


(* Set.cross s t  exists for hol and isabelle*)
let cross s t = (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun s x2 -> Pset.fold
                  (fun t x2 -> if true then Pset.add (s,t) x2 else x2) 
                t x2) s x2)


(* indreln {isabelle} *)
(*   forall r x y. r (x, y) ==> tc' r (x, y) and  *)
(*   forall r x y. (exist z. tc' r (x,z) && tc' r (z,y)) ==> tc' r (x,y)  *)

(* let {isabelle} tc r = *)
(*  let r' = fun (x,y) -> ((x,y) IN r) in   *)
(*  { (x,y) | forall ((x,y) IN r) | tc' r' (x,y) } *)

(*val tc : forall 'a. set ('a * 'a) -> set ('a * 'a)*)
let rec tc r =  
(let one_step = (let x2 =
  (Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun(x,y) x2 -> Pset.fold
                     (fun(y',z) x2 ->
                      if y = y' then Pset.add (x,z) x2 else x2) r x2) 
 r x2) in
  if Pset.subset  one_step  r then r else
  tc ( Pset.union one_step r))

let set_restrict rel s = ( Pset.inter  (rel)  (cross s s))

let strict_partial_order ord = ( irrefl ord && trans ord)

let relation_over s rel = ( 
  Pset.for_all (fun (a,b) -> Pset.mem a s && Pset.mem b s) rel) 

let inj_on f a =
    ( Pset.for_all
   (fun x -> ( Pset.for_all (fun y -> ( not (f x = f y) || (x = y))) a)) a)

let total s ord =
     ( Pset.for_all
   (fun x -> Pset.for_all
               (fun y -> Pset.mem (x,y) ord ||
                         ( Pset.mem (y,x) ord || (x = y))) s) s)

let strict_total_order_over s ord =    
(
    relation_over s ord &&
    (
    strict_partial_order ord &&
    total s ord))

let adjacent_less_than ord s x y = ( Pset.mem 
    (x,y)  ord && not ( 
  Pset.exists (fun z -> Pset.mem (x,z) ord && Pset.mem (z,y) ord) s))
    
let adjacent_less_than_such_that pred ord s x y =    
(pred x && ( Pset.mem  (x,y)  ord && not ( 
  Pset.exists (fun z -> pred z && ( Pset.mem (x,z) ord && Pset.mem (z,y) ord)) s)))

(*val finite : forall 'a. set 'a -> bool*)
let finite s = true


(*val finite_prefixes : forall 'a. set ('a * 'a) -> set 'a -> bool*)
let finite_prefixes r s = true

(*************************************************** *)
(* 2 - Type definitions and projections *)
(*************************************************** *)


(*************************************************** *)
(* - 2.1 - Action and location types *)
(*************************************************** *)


(**** Cppmem base types ****)

type flexsym = string

type cst =
  | Concrete of num
  | Symbolic of string

type cvalue =
  | Rigid of cst
  | Flexible of flexsym

type aid = string
type tid = cvalue
type location = cvalue
type program = num



type memory_order =
  | NA
  | Seq_cst
  | Relaxed
  | Release
  | Acquire
  | Consume
  | Acq_rel

type lock_outcome =
    Locked
  | Blocked

type action =
  | Lock of aid * tid * location * lock_outcome
  | Unlock of aid * tid * location
  | Load of aid * tid * memory_order * location * cvalue
  | Store of aid * tid * memory_order * location * cvalue
  | RMW of aid * tid * memory_order * location * cvalue * cvalue
  | Fence of aid * tid * memory_order
  | Blocked_rmw of aid * tid * location



(*********************************************** *)
(*  - 2.2 - Execution records *)
(*********************************************** *)

type location_kind =
    Mutex
  | Non_Atomic
  | Atomic

type pre_execution =
  {  actions : action set;
      threads : tid set;
      lk      : location -> location_kind;
      sb      : (action * action) set ;
      asw     : (action * action) set ;
      dd      : (action * action) set ;
  }

type order_kind =
     Global_order
   | Per_location_order

type relation_usage_flags =
  {  rf_flag  : bool;
      mo_flag  : bool;
      sc_flag  : bool;
      lo_flag  : bool;
      ao_flag  : bool;
      tot_flag : bool;  }

type execution_witness =
  {  rf      : (action * action) set;
      mo      : (action * action) set;
      sc      : (action * action) set;
      lo      : (action * action) set;
      ao      : (action * action) set;
      tot     : (action * action) set;
 }

type relation_list = (string * (action * action) set) list

type complete_execution = (pre_execution * execution_witness * relation_list)

type observable_execution = (pre_execution * execution_witness)

type program_behaviours =
    Defined of observable_execution set
  | Undefined

type rf_observable_execution = (pre_execution * (action * action) set)

type rf_program_behaviours =
    Rf_Defined of rf_observable_execution set
  | Rf_Undefined

type named_predicate_tree =
    Leaf of (complete_execution -> bool)
  | Node of (string * named_predicate_tree) list


(*val named_predicate_tree_measure : named_predicate_tree -> num*)

let rec apply_tree pred_tree x =  
((match pred_tree with
    | Leaf( p) -> p x
    | Node( l) -> List.for_all (fun (name, branch) -> apply_tree branch x) l
  ))


type fault_setgen =
    One of (string * (complete_execution -> action set))
  | Two of (string * (complete_execution -> (action * action) set))


let is_fault faults_list (xo,xw,rl) a =    
(let is_particular_fault f =      
((match f with
        One( (_name,setgen)) -> ( Pset.mem a  (setgen (xo,xw,rl)))
      | Two( (_name,setgen)) -> 
  Pset.exists
    (fun b ->
     ( Pset.mem (a,b) (setgen (xo,xw,rl))) ||
     ( Pset.mem (b,a) (setgen (xo,xw,rl)))) xo.actions )) in List.exists is_particular_fault faults_list)

let each_empty faults_list x =    
(let faults_empty f =      
((match f with
        One( (_name,setgen)) -> Pset.is_empty (setgen x)
      | Two( (_name,setgen)) -> Pset.is_empty (setgen x) )) in List.for_all faults_empty faults_list)


type opsem_t = program -> pre_execution -> bool


type protocol_t = complete_execution -> bool

let true_protocol _ = true


(*val statically_satisfied : protocol_t -> opsem_t -> program -> bool*)


type memory_model =
  {  consistent : named_predicate_tree;
      relation_calculation : pre_execution -> execution_witness ->
  relation_list;
      undefined : fault_setgen list;
      relation_flags : relation_usage_flags;
  }

(*val observable_filter : set complete_execution -> set observable_execution*)

(*val behaviour : memory_model -> protocol_t -> opsem_t -> program -> program_behaviours*)


(*val rf_observable_filter : set complete_execution -> set rf_observable_execution*)


(*val rf_behaviour : memory_model -> protocol_t -> opsem_t -> program -> rf_program_behaviours*)

(*
val behaviour : memory_model -> memory_model -> protocol_t -> opsem_t -> program -> program_behaviours
let rf_equivalent M M' =
*)



(*************************************************** *)
(*   - 2.3 - Projection functions *)
(*************************************************** *)


let aid_of a =    
((match a with
    | Lock( aid, _, _, _)            -> aid
    | Unlock( aid, _, _)            -> aid
    | Load( aid, _, _, _, _)          -> aid
    | Store( aid, _, _, _, _)         -> aid
    | RMW( aid, _, _, _, _, _)         -> aid
    | Fence( aid, _, _)             -> aid
    | Blocked_rmw( aid, _, _)       -> aid
    ))


let tid_of a =    
((match a with
      Lock( _, tid, _, _)           -> tid
    | Unlock( _, tid, _)           -> tid
    | Load( _, tid, _, _, _)         -> tid
    | Store( _, tid, _, _, _)        -> tid
    | RMW( _, tid, _, _, _, _)        -> tid
    | Fence( _, tid, _)            -> tid
    | Blocked_rmw( _, tid, _)      -> tid
    ))



let loc_of a =    
((match a with
      Lock( _, _, l, _)           -> Some( l)
    | Unlock( _, _, l)           -> Some( l)
    | Load( _, _, _, l, _)         -> Some( l)
    | Store( _, _, _, l, _)        -> Some( l)
    | RMW( _, _, _, l, _, _)        -> Some( l)
    | Fence( _, _, _)            -> None
    | Blocked_rmw( _, _, l)      -> Some( l)
    ))

let value_read_by a =    
((match a with
      Load( _, _, _, _, v)         -> Some( v)
    | RMW( _, _, _, _, v, _)        -> Some( v)
    | _                      -> None
    ))


let value_written_by a =    
((match a with
      Store( _, _, _, _, v)        -> Some( v)
    | RMW( _, _, _, _, _, v)        -> Some( v)
    | _                      -> None
    ))

let is_lock a =    
((match a with
      Lock( _, _, _, _) -> true
    | _            -> false
    ))

let is_successful_lock a =    
((match a with
      Lock( _, _, _, Locked) -> true
    | _                  -> false
    ))

let is_blocked_lock a =    
((match a with
      Lock( _, _, _, Blocked) -> true
    | _                  -> false
    ))

let is_unlock a =    
((match a with
      Unlock( _, _, _) -> true
    | _            -> false
    ))

let is_atomic_load a =    
((match a with
      Load( _, _, mo, _, _) -> mo <> NA
    | _               -> false
    ))

let is_atomic_store a =    
((match a with
      Store( _, _, mo, _, _) -> mo <> NA
    | _                -> false
    ))

let is_RMW a =    
((match a with
      RMW( _, _, _, _, _, _) -> true
    | _               -> false
    ))

let is_blocked_rmw a =    
((match a with
      Blocked_rmw( _, _, _) -> true
    | _                 -> false
    ))

let is_NA_load a =    
((match a with
      Load( _, _, mo, _, _) -> mo = NA
    | _               -> false
    ))

let is_NA_store a =    
((match a with
      Store( _, _, mo, _, _) -> mo = NA
    | _                -> false
    ))

let is_load a =    
((match a with
      Load( _, _, _, _, _) -> true
    | _              -> false
    ))

let is_store a =    
((match a with
      Store( _, _, _, _, _) -> true
    | _               -> false
    ))

let is_fence a =    
((match a with
      Fence( _, _, _) -> true
    | _           -> false
    ))

let is_atomic_action a =    
((match a with
      Load( _, _, mo, _, _)  -> mo <> NA
    | Store( _, _, mo, _, _) -> mo <> NA
    | RMW( _, _, _, _, _, _)  -> true
    | _                -> false
    ))

let is_read a =    
((match a with
      Load( _, _, _, _, _)  -> true
    | RMW( _, _, _, _, _, _) -> true
    | _               -> false
    ))

let is_write a =    
((match a with
      Store( _, _, _, _, _) -> true
    | RMW( _, _, _, _, _, _) -> true
    | _               -> false
    ))


(* It is important to note that seq_cst atomics are both acquires and releases *)


let is_acquire a =    
 ((match a with
      Load( _, _, mo, _, _)  -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Acquire;Seq_cst])
    | RMW( _, _, mo, _, _, _) -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Acquire;Acq_rel;Seq_cst])
    | Fence( _, _, mo)     -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Acquire;Consume;Acq_rel;Seq_cst])
    | _                -> false
    ))

let is_release a =    
 ((match a with
      Store( _, _, mo, _, _)  -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Release;Seq_cst])
    | RMW( _, _, mo, _, _, _)  -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Release;Acq_rel;Seq_cst])
    | Fence( _, _, mo)      -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Release;Acq_rel;Seq_cst])
    | _                 -> false
    ))

let is_consume a =    
 ((match a with
      Load( _, _, mo, _, _)  -> mo = Consume
    | _                -> false
    ))


let is_seq_cst a =    
((match a with
      Load( _, _, mo, _, _)  -> mo = Seq_cst
    | Store( _, _, mo, _, _) -> mo = Seq_cst
    | RMW( _, _, mo, _, _, _) -> mo = Seq_cst
    | Fence( _, _, mo)     -> mo = Seq_cst
    | _                -> false
    ))


let threadwise s rel = ( 
  Pset.for_all (fun (a,b) -> tid_of a = tid_of b) rel)

let locationwise s rel = ( 
  Pset.for_all (fun (a,b) -> loc_of a = loc_of b) rel)

let per_location_total s rel = ( 
  Pset.for_all
    (fun a -> Pset.for_all
                (fun b -> ( not ( loc_of a = loc_of b) ||
                            ( Pset.mem (a,b) rel ||
                              ( Pset.mem (b,a) rel || (a = b))))) s) s)


(**************************************** *)
(*   - 2.4 - Location kinds *)
(**************************************** *)


let actions_respect_location_kinds actions lk = ( 
  Pset.for_all
    (fun a -> (match a with
                    | Lock ( _, _, l, _) -> lk l = Mutex
                | Unlock ( _, _, l) -> lk l = Mutex
                | Load ( _, _, mo, l, _) ->
              (mo = NA && (lk l = Non_Atomic)) ||
              (mo <> NA && (lk l = Atomic))
                | Store ( _, _, mo, l, _) ->
              (mo = NA && (lk l = Non_Atomic)) || (lk l = Atomic)
                | RMW ( _, _, _, l, _, _) -> lk l = Atomic
                | Fence ( _, _, _) -> true
                | Blocked_rmw ( _, _, l) -> lk l = Atomic
              )) actions)


let is_at_mutex_location lk a =    
((match loc_of a with
      Some( l) -> (lk l = Mutex)
    | None   -> false
    ))

let is_at_non_atomic_location lk a =    
((match loc_of a with
      Some( l) -> (lk l = Non_Atomic)
    | None   -> false
    ))

let is_at_atomic_location lk a =    
((match loc_of a with
      Some( l) -> (lk l = Atomic)
    | None   -> false
    ))



(**************************************** *)
(*   - 3.1 - Well formed action *)
(**************************************** *)


(* used in cppmem *)
let locations_of actions =
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun x1 x2 -> (match x1 with
                     Some ( l) ->
                 if true then Pset.add l x2 else x2
                   | _ -> x2
                 ))
   (let x2 =(Pset.from_list Pervasives.compare []) in
    Pset.fold (fun a x2 -> if true then Pset.add (loc_of a) x2 else x2)
      actions x2) x2)


let well_formed_action a =  
((match a with
    | Load(  _, _, mo, _, _) -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [NA;Relaxed;Acquire;Seq_cst;Consume])
    | Store( _, _, mo, _, _) -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [NA;Relaxed;Release;Seq_cst])
    | RMW( _, _, mo, _, _, _) -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare [Relaxed;Release;Acquire;Acq_rel;Seq_cst])
    | Fence( _, _, mo)     -> Pset.mem  mo 
  (Pset.from_list Pervasives.compare
     [Relaxed;Release;Acquire;Acq_rel;Consume;Seq_cst])
    | _                -> true
    ))

(*********************************************** *)
(*  - 3.2 - Well formed threads *)
(*********************************************** *)



let assumptions (xo,xw,_) =  
(
  finite_prefixes xo.sb  xo.actions &&
  (
  finite_prefixes xo.asw xo.actions &&
  (
  finite_prefixes xw.rf  xo.actions &&
  (
  finite_prefixes xw.mo  xo.actions &&
  (
  finite_prefixes xw.sc  xo.actions &&
  (
  finite_prefixes xw.lo  xo.actions &&
  (
  relation_over xo.actions xo.asw && 
  Pset.for_all (fun (a,b) -> tid_of a <> tid_of b) xo.asw)))))))
(*  finite_prefixes (tc (Xo.sb union Xo.asw)) Xo.actions && *)
(*  irrefl (tc (Xo.sb union Xo.asw)) &&*)
(*finite {Xo.threads} &&*)
(*  forall (b IN Xo.actions).
    finite { a | forall (a IN Xo.actions) |
             (tid_of a = tid_of b) && not ((a,b) IN Xo.sb || (b,a) IN Xo.sb) }
*)




(*

Finite prefixes thoughts.

I need to union and then tc two relations. The first is tc (sb U asw). I know that has finite prefixes, and is acyclic. First consider adding in lock order


( hb SUBSET (tc(sb union asw union lo)) /\
  finite_prefixes Xo.actions tc(sb union asw) /\
  trans Xw.lo /\
  irrefl Xw.lo /\
  forall (a IN Xo.actions) (b IN Xo.actions).
    (a,b) IN Xw.lo --> not ((b,a) IN hb)
) ==>


*)


let blocking_observed actions sb =
    ( Pset.for_all
   (fun a ->
    ( not (is_blocked_rmw a || is_blocked_lock a) ||
      not ( Pset.exists (fun b -> Pset.mem (a,b) sb) actions))) actions)

(* Indeterminate sequencing from 1.9p15, noting that all atomic and
lock calls are functions. *)
let indeterminate_sequencing xo = ( 
  Pset.for_all
    (fun a -> Pset.for_all
                (fun b -> ( not
                              ((tid_of a = tid_of b) &&
                               ((a <> b) &&
                                not
                                  (is_at_non_atomic_location xo.lk a &&
                                   is_at_non_atomic_location xo.lk b))) ||
                            ( Pset.mem (a,b) xo.sb || Pset.mem (b,a) xo.sb)))
                xo.actions) xo.actions)


let well_formed_threads (xo,_,_) =    
(( Pset.for_all (fun a -> well_formed_action a) xo.actions) &&
    (
    actions_respect_location_kinds xo.actions xo.lk &&
    (
    blocking_observed xo.actions xo.sb &&
    (
    inj_on aid_of xo.actions &&
    (
    relation_over xo.actions xo.sb &&
    (
    relation_over xo.actions xo.asw &&
    (
    threadwise xo.actions xo.sb &&
    (
    strict_partial_order xo.sb &&
    (
    strict_partial_order xo.dd && ( Pset.subset 
    xo.dd  xo.sb &&
    indeterminate_sequencing xo))))))))))


(*********************************************** *)
(* 4 - Memory_Model simplified, single thread, no atomics *)
(*********************************************** *)


let visible_side_effect_set actions hb =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun(a,b) x2 ->
    if
    is_write a &&
    ( is_read b &&
      ((loc_of a = loc_of b) &&
       not
         ( Pset.exists
             (fun c -> not
                         ( Pset.mem c
                             (Pset.from_list Pervasives.compare [a;b])) &&
                       (
                       is_write c &&
                       ((loc_of c = loc_of b) &&
                        ( Pset.mem (a,c) hb && Pset.mem (c,b) hb)))) 
           actions))) then Pset.add (a,b) x2 else x2) hb x2)

let det_read (xo,xw,_::("vse",vse)::_) = ( 
  Pset.for_all
    (fun r -> ( not ( is_load r) ||
                (( Pset.exists (fun w -> Pset.mem (w,r) vse) xo.actions) =
                 ( Pset.exists (fun w' -> Pset.mem (w',r) xw.rf) xo.actions)))) xo.actions)

let consistent_non_atomic_rf (xo,xw,_::("vse",vse)::_) = ( 
  Pset.for_all
    (fun (w,r) -> ( not ( is_at_non_atomic_location xo.lk r) ||
                    Pset.mem (w,r) vse)) xw.rf)

let well_formed_rf (xo,xw,_) = ( 
  Pset.for_all
    (fun (a,b) -> Pset.mem a xo.actions &&
                  ( Pset.mem b xo.actions &&
                    (
                    loc_of a = loc_of b &&
                    (
                    is_write a &&
                    ( is_read b &&
                      (
                      value_read_by b = value_written_by a &&
                      Pset.for_all
                        (fun a' -> ( not ( Pset.mem (a',b) xw.rf) || (a = a')))
                        xo.actions)))))) xw.rf)


let sc_mo_lo_empty (_,xw,_) = ( Pset.is_empty xw.sc && ( Pset.is_empty xw.mo && Pset.is_empty xw.lo))

let single_thread_relations xo xw =    
(let hb    = (xo.sb) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse) ])

let single_thread_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("sc_mo_lo_empty", Leaf( sc_mo_lo_empty));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf)) ])) ]))


(*********************************************** *)

let indeterminate_reads (xo,xw,_) =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun b x2 ->
    if is_read b &&
       not ( Pset.exists (fun a -> Pset.mem (a,b) xw.rf) xo.actions) then
      Pset.add b x2 else x2) xo.actions x2)

let unsequenced_races (xo,_,_) =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   is_at_non_atomic_location xo.lk a &&
                   ( not (a = b) &&
                     ((loc_of a = loc_of b) &&
                      ((is_write a || is_write b) &&
                       ((tid_of a = tid_of b) &&
                        not ( Pset.mem (a,b) xo.sb || Pset.mem (b,a) xo.sb))))) then
                     Pset.add (a,b) x2 else x2) xo.actions x2) xo.actions 
 x2)


let single_thread_undefined_behaviour =  
([ Two( ("unsequenced_races", unsequenced_races));
    One( ("indeterminate_reads", indeterminate_reads)) ])


(*val single_thread_protocol : protocol_t*)
let single_thread_protocol ((xo,_,_):complete_execution) = ( 
  Pset.exists
    (fun b -> Pset.for_all
                (fun a ->
                 (tid_of a = tid_of b) &&
                 (match (loc_of a) with
                     None -> false
                   | Some ( l) -> (xo.lk l = Non_Atomic)
                 )) xo.actions) xo.actions)


let single_thread_memory_model =  
({ consistent = single_thread_consistent_execution;
     relation_calculation = single_thread_relations;
     undefined = single_thread_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = false;
           sc_flag  = false;
           lo_flag  = false;
           ao_flag  = false;
           tot_flag = false }
  })



(*val single_thread_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 5 - Memory_Model simplified, multi-thread, no atomics, yes locks *)
(*********************************************** *)


let locks_only_sw actions asw lo a b =  
((tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    (is_unlock a && ( is_successful_lock b && Pset.mem  (a,b)  lo))
  ))

let locks_only_sw_set actions asw lo =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if locks_only_sw actions asw lo a b then Pset.add (a,b) x2
                   else x2) actions x2) actions x2)

let no_consume_hb sb sw =    
(
    tc ( Pset.union sb sw))

let locks_only_relations xo xw =    
(let sw    = ( locks_only_sw_set xo.actions xo.asw xw.lo) in
    let hb    = ( no_consume_hb xo.sb sw) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw) ])


let sc_mo_empty (_,xw,_) = ( Pset.is_empty xw.sc && Pset.is_empty xw.mo)
    

let locks_only_consistent_lo (xo,xw,("hb",hb)::_) =    
(
    relation_over xo.actions xw.lo &&
    (
    trans xw.lo &&
    (
    irrefl xw.lo && Pset.for_all
   (fun a -> Pset.for_all
               (fun b -> ( not ( Pset.mem (a,b) xw.lo) ||
                           ( not ( Pset.mem (b,a) hb) &&
                             (( Pset.mem (a,b) xw.lo || Pset.mem (b,a) xw.lo) =
                              ( ( not (a = b)) &&
                                ((is_lock a || is_unlock a) &&
                                 ((is_lock b || is_unlock b) &&
                                  ((loc_of a = loc_of b) &&
                                   is_at_mutex_location xo.lk a))) )))))
               xo.actions) xo.actions)))



let locks_only_consistent_locks (xo,xw,_) =
    ( Pset.for_all
   (fun (a,c) ->
    ( not ( is_successful_lock a && is_successful_lock c) ||
      ( Pset.exists
          (fun b -> is_unlock b &&
                    ( Pset.mem (a,b) xw.lo && Pset.mem (b,c) xw.lo))
          xo.actions))) xw.lo)


let consistent_hb (xo,_,("hb",hb)::_) =    
(
    irrefl (tc hb))


let locks_only_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("sc_mo_empty", Leaf( sc_mo_empty));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf)) ])) ]))


(*********************************************** *)


let locks_only_good_mutex_use actions lk sb lo a =    
(
    (* violated requirement: The calling thread shall own the mutex. *)( ( not ( is_unlock a) || 
        ( Pset.exists
   (fun al ->
    is_successful_lock al &&
    ( Pset.mem (al,a) sb && adjacent_less_than lo actions al a)) actions )) ) &&
    (* violated requirement: The calling thread does not own the mutex. *)
    ( ( not ( is_lock a) || not ( 
  Pset.exists
    (fun al ->
     is_successful_lock al &&
     ( Pset.mem (al,a) sb && adjacent_less_than lo actions al a)) actions )) ))


let locks_only_bad_mutexes (xo,xw,_) =  
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 ->
    if not (locks_only_good_mutex_use xo.actions xo.lk xo.sb xw.lo a) then
      Pset.add a x2 else x2) xo.actions x2)


let data_races (xo,xw,("hb",hb)::_) =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if not (a = b) &&
                      ((loc_of a = loc_of b) &&
                       ((is_write a || is_write b) &&
                        ((tid_of a <> tid_of b) &&
                         ( not (is_atomic_action a && is_atomic_action b) &&
                           not ( Pset.mem (a,b) hb || Pset.mem (b,a) hb))))) then
                     Pset.add (a,b) x2 else x2) xo.actions x2) xo.actions 
 x2)


let good_mutex_use actions lk sb lo a =    
(let mutexes_at_l =      
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a' x2 ->
    if (is_lock a' || is_unlock a') && (loc_of a' = loc_of a) then
      Pset.add a' x2 else x2) actions x2)
    in
    let lock_order = ( set_restrict lo mutexes_at_l) in
    (* violated requirement: The calling thread shall own the mutex. *)
    ( ( not ( is_unlock a) ||  ( 
  Pset.exists
    (fun al ->
     is_successful_lock al &&
     ( Pset.mem (al,a) sb && adjacent_less_than lock_order actions al a)) actions )) ) &&
    (* violated requirement: The calling thread does not own the mutex. *)
    ( ( not ( is_lock a) || not ( 
  Pset.exists
    (fun al ->
     is_successful_lock al &&
     ((tid_of a = tid_of al) && adjacent_less_than lock_order actions al a)) actions )) ))


let bad_mutexes (xo,xw,_) =  
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 ->
    if not (good_mutex_use xo.actions xo.lk xo.sb xw.sc a) then Pset.add a x2
    else x2) xo.actions x2)



let locks_only_undefined_behaviour =  
([ Two( ("unsequenced_races", unsequenced_races));
    Two( ("data_races", data_races));
    One( ("indeterminate_reads", indeterminate_reads));
    One( ("locks_only_bad_mutexes", locks_only_bad_mutexes)) ])


(*********************************************** *)


(*val locks_only_protocol : protocol_t*)
let locks_only_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match (loc_of a) with
         None -> false
       | Some ( l) -> ( Pset.mem (xo.lk l)
                          (Pset.from_list Pervasives.compare
                             [Mutex;Non_Atomic]))
     )) xo.actions)


let locks_only_memory_model =  
({ consistent = locks_only_consistent_execution;
     relation_calculation = locks_only_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = false;
           sc_flag  = false;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })

(*val locks_only_behaviour : opsem_t -> program -> program_behaviours*)


(*********************************************** *)
(* 6 - relaxed - memory_model simplified for programs without sc,
consumes, release or acquire *)
(*********************************************** *)


let sc_empty (_,xw,_) = ( Pset.is_empty xw.sc)

let consistent_atomic_rf (xo,xw,("hb",hb)::_) = ( 
  Pset.for_all
    (fun (w,r) -> ( not ( is_at_atomic_location xo.lk r && is_load r) ||
                    not ( Pset.mem (r,w) hb))) xw.rf)

let rmw_atomicity (xo,xw,_) = ( 
  Pset.for_all
    (fun b -> Pset.for_all
                (fun a -> ( not ( is_RMW b) ||
                            (adjacent_less_than xw.mo xo.actions a b =
                             ( Pset.mem (a,b) xw.rf)))) xo.actions) xo.actions)


let coherent_memory_use (xo,xw,("hb",hb)::_) =    
(
    (* CoRR *)( not ( 
  Pset.exists
    (fun (a,b) -> Pset.exists
                    (fun (c,d) -> Pset.mem (b,d) hb && Pset.mem (c,a) xw.mo)
                    xw.rf) xw.rf ) ) &&
    (* CoWR *)
    (( not ( Pset.exists
   (fun (a,b) -> Pset.exists
                   (fun c -> Pset.mem (c,b) hb && Pset.mem (a,c) xw.mo)
                   xo.actions) xw.rf ) ) &&
    (* CoRW *)
    (( not ( Pset.exists
   (fun (a,b) -> Pset.exists
                   (fun c -> Pset.mem (b,c) hb && Pset.mem (c,a) xw.mo)
                   xo.actions) xw.rf ) ) &&
    (* CoWW *)
    ( not ( Pset.exists (fun (a,b) -> Pset.mem (b,a) xw.mo) hb) ))))


let consistent_mo (xo,xw,_) =    
(
    relation_over xo.actions xw.mo &&
    (
    trans xw.mo &&
    (
    irrefl xw.mo && Pset.for_all
   (fun a -> Pset.for_all
               (fun b ->
                ( Pset.mem (a,b) xw.mo || Pset.mem (b,a) xw.mo) =
                ( ( not (a = b)) &&
                  (
                  is_write a &&
                  ( is_write b &&
                    ((loc_of a = loc_of b) && is_at_atomic_location xo.lk a))) ))
               xo.actions) xo.actions)))


let relaxed_only_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("sc_empty", Leaf( sc_empty));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity)) ])) ]))


(*val relaxed_only_protocol : protocol_t*)
let relaxed_only_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> Pset.mem mo
                                     (Pset.from_list Pervasives.compare
                                        [NA;Relaxed])
       | Store ( _, _, mo, _, _) -> Pset.mem mo
                                      (Pset.from_list Pervasives.compare
                                         [NA;Relaxed])
       | RMW ( _, _, mo, _, _, _) -> Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [Relaxed])
       | Fence ( _, _, _) -> false
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)


(*********************************************** *)


let relaxed_only_memory_model =  
({ consistent = relaxed_only_consistent_execution;
     relation_calculation = locks_only_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val relaxed_only_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 7 - release acquire - memory_model simplified for programs without sc,
consumes or relaxed *)
(*********************************************** *)

(* Unused in this model currently, causes me to encounter the non-atomic LB writes problem, which can be solved for the simpler model. *)
let release_acquire_coherent_memory_use (xo,xw,("hb",hb)::_) =    
(
    (* CoWR *)( not ( 
  Pset.exists
    (fun (a,b) -> Pset.exists
                    (fun c -> Pset.mem (c,b) hb && Pset.mem (a,c) xw.mo)
                    xo.actions) xw.rf ) ) &&
    (* CoWW *)
    ( not ( Pset.exists (fun (a,b) -> Pset.mem (b,a) xw.mo) hb) ))


let atomic_initialisation_first (xo,_,_) = ( 
  Pset.for_all
    (fun a -> Pset.for_all
                (fun b -> ( not
                              (
                              is_at_atomic_location xo.lk a &&
                              ( is_NA_store a &&
                                ( is_write b && (loc_of a = loc_of b)))) ||
                            (( Pset.mem (a,b)
                                 ( tc ( Pset.union xo.sb xo.asw))) &&
                             not (is_NA_store b)))) xo.actions) xo.actions)

(* Deprecated, TODO remove, rework proofs *)
let atomic_unsequenced_races (xo,_,_) =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   is_at_atomic_location xo.lk a &&
                   ( not (a = b) &&
                     ((loc_of a = loc_of b) &&
                      ((is_write a || is_write b) &&
                       ((tid_of a = tid_of b) &&
                        not ( Pset.mem (a,b) xo.sb || Pset.mem (b,a) xo.sb))))) then
                     Pset.add (a,b) x2 else x2) xo.actions x2) xo.actions 
 x2)


(*val release_acquire_protocol : protocol_t*)
let release_acquire_protocol ((xo,xw,rl):complete_execution) =    
(
    atomic_initialisation_first (xo,xw,rl) && ( Pset.is_empty (atomic_unsequenced_races (xo,xw,rl)) && 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release]))
       | RMW ( _, _, mo, _, _, _) -> mo = Acq_rel
       | Fence ( _, _, _) -> false
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions))


let release_acquire_synchronizes_with actions sb asw rf lo a b =  
((tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && ( is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    ( is_release a && ( is_acquire b && Pset.mem  (a,b)  rf) ))
  ))

let release_acquire_synchronizes_with_set actions sb asw rf lo =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   release_acquire_synchronizes_with actions sb asw rf lo a b then
                     Pset.add (a,b) x2 else x2) actions x2) actions x2)

let release_acquire_relations xo xw =    
(let sw    = ( release_acquire_synchronizes_with_set
                  xo.actions xo.sb xo.asw xw.rf xw.lo) in
    let hb    = ( no_consume_hb xo.sb sw) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw) ])


(*********************************************** *)


(* Unused currently, see R/A coherence above *)
let release_acquire_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("sc_empty", Leaf( sc_empty));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("release_acquire_coherent_memory_use", Leaf( release_acquire_coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity)) ])) ]))


let release_acquire_memory_model =  
({ consistent = relaxed_only_consistent_execution;
    relation_calculation = release_acquire_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val release_acquire_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 8 - release_acquire_relaxed - memory_model simplified for programs without sc,
consumes or relaxed *)
(*********************************************** *)


(*val release_acquire_relaxed_protocol : protocol_t*)
let release_acquire_relaxed_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire;Relaxed]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release;Relaxed]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Acq_rel;Acquire;Release;Relaxed]))
       | Fence ( _, _, _) -> false
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)


let release_acquire_relaxed_synchronizes_with actions sb asw rf lo rs a b =  
((tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && ( is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    ( is_release a && ( is_acquire b &&
      ( Pset.exists (fun c -> Pset.mem (a,c) rs && Pset.mem (c,b) rf) actions)) ))
  ))


let rs_element head a =    
((tid_of a = tid_of head) || is_RMW a)


let release_sequence_set actions lk mo =  
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun rel x2 -> Pset.fold
                    (fun b x2 ->
                     if
                     is_release rel &&
                     ( (b = rel) ||
                       ( Pset.mem (rel,b) mo &&
                         (
                         rs_element rel b &&
                         Pset.for_all
                           (fun c -> ( not
                                         ( Pset.mem (rel,c) mo &&
                                           Pset.mem (c,b) mo) ||
                                       rs_element rel c)) actions) ) ) then
                       Pset.add (rel,b) x2 else x2) actions x2) actions 
 x2)


let release_acquire_relaxed_synchronizes_with_set actions sb asw rf lo rs =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   release_acquire_relaxed_synchronizes_with actions sb asw
                     rf lo rs a b then Pset.add (a,b) x2 else x2) actions 
                x2) actions x2)

let release_acquire_relaxed_relations xo xw =    
(let rs    = ( release_sequence_set xo.actions xo.lk xw.mo) in
    let sw    = ( release_acquire_relaxed_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs) in
    let hb    = ( no_consume_hb xo.sb sw) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("rs", rs) ])


(*********************************************** *)


let release_acquire_relaxed_memory_model =  
({ consistent = relaxed_only_consistent_execution;
     relation_calculation = release_acquire_relaxed_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val release_acquire_relaxed_behaviour : opsem_t -> program -> program_behaviours*)




(*********************************************** *)
(* 9 - release_acquire_fenced *)
(*********************************************** *)


(*val release_acquire_fenced_protocol : protocol_t*)
let release_acquire_fenced_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire;Relaxed]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release;Relaxed]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Acq_rel;Acquire;Release;Relaxed]))
       | Fence ( _, _, mo) -> ( Pset.mem mo
                                  (Pset.from_list Pervasives.compare
                                     [Release;Acquire;Relaxed]))
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)


let release_acquire_fenced_synchronizes_with actions sb asw rf lo rs hrs a b =  
((tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && ( is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    (( is_release a && ( is_acquire b &&
      ( Pset.exists (fun c -> Pset.mem (a,c) rs && Pset.mem (c,b) rf) actions)) ) ||
    (* fence synchronisation *)
    (( is_fence a && ( is_release a && ( is_fence b && ( is_acquire b && 
  Pset.exists
    (fun x -> Pset.exists
                (fun z -> Pset.exists
                            (fun y -> Pset.mem (a,x) sb &&
                                      ( Pset.mem (x,z) hrs &&
                                        ( Pset.mem (z,y) rf &&
                                          Pset.mem (y,b) sb))) actions)
                actions) actions)))) ||
    (( is_fence a && ( is_release a && ( is_acquire b && 
  Pset.exists
    (fun x -> Pset.exists
                (fun y -> Pset.mem (a,x) sb &&
                          ( Pset.mem (x,y) hrs && Pset.mem (y,b) rf)) 
              actions) actions)) ) ||
    ( is_release a && ( is_fence b && ( is_acquire b && 
  Pset.exists
    (fun y -> Pset.exists
                (fun x -> Pset.mem (a,y) rs &&
                          ( Pset.mem (y,x) rf && Pset.mem (x,b) sb)) 
              actions) actions))))))) ))


let hypothetical_release_sequence_set actions lk mo =  
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   is_atomic_action a &&
                   (
                   is_write a &&
                   ( (b = a) ||
                     ( Pset.mem (a,b) mo &&
                       (
                       rs_element a b &&
                       Pset.for_all
                         (fun c -> ( not
                                       ( Pset.mem (a,c) mo &&
                                         Pset.mem (c,b) mo) || rs_element a c))
                         actions) ) )) then Pset.add (a,b) x2 else x2)
                  actions x2) actions x2)


let release_acquire_fenced_synchronizes_with_set actions sb asw rf lo rs hrs =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   release_acquire_fenced_synchronizes_with actions sb asw rf
                     lo rs hrs a b then Pset.add (a,b) x2 else x2) actions 
                x2) actions x2)



let release_acquire_fenced_relations xo xw =    
(let hrs   = ( hypothetical_release_sequence_set xo.actions xo.lk xw.mo) in
    let rs    = ( release_sequence_set xo.actions xo.lk xw.mo) in
    let sw    = ( release_acquire_fenced_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs) in
    let hb    = ( no_consume_hb xo.sb sw) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs) ])


(*********************************************** *)


let release_acquire_fenced_memory_model =  
({ consistent = relaxed_only_consistent_execution;
     relation_calculation = release_acquire_fenced_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val release_acquire_fenced_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 10 - sc, no sc fences *)
(*********************************************** *)


(*val sc_accesses_protocol : protocol_t*)
let sc_accesses_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire;Relaxed;Seq_cst]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release;Relaxed;Seq_cst]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Acq_rel;Acquire;Release;Relaxed;Seq_cst]))
       | Fence ( _, _, mo) -> ( Pset.mem mo
                                  (Pset.from_list Pervasives.compare
                                     [Release;Acquire;Relaxed]))
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)



let sc_accesses_consistent_sc (xo,xw,("hb",hb)::_) =    
(
    relation_over xo.actions xw.sc &&
    (
    trans xw.sc &&
    (
    irrefl xw.sc && Pset.for_all
   (fun a -> Pset.for_all
               (fun b ->
                ( ( not ( Pset.mem (a,b) xw.sc) ||
                    not ( Pset.mem (b,a) ( Pset.union hb xw.mo)))) &&
                ( ( Pset.mem (a,b) xw.sc || Pset.mem (b,a) xw.sc) =
                  ( ( not (a = b)) && ( is_seq_cst a && is_seq_cst b)) ))
               xo.actions) xo.actions)))


let sc_accesses_sc_reads_restricted (xo,xw,("hb",hb)::_) = ( 
  Pset.for_all
    (fun (w,r) -> ( not ( is_seq_cst r) ||
                    (( is_seq_cst w &&
                       ( Pset.mem (w,r) xw.sc &&
                         not
                           ( Pset.exists
                               (fun w' ->
                                is_write w' &&
                                ((loc_of w = loc_of w') &&
                                 ( Pset.mem (w,w') xw.sc &&
                                   Pset.mem (w',r) xw.sc))) xo.actions )) ) ||
                     ( not (is_seq_cst w) &&
                       not
                         ( Pset.exists
                             (fun w' ->
                              is_write w' &&
                              ((loc_of w = loc_of w') &&
                               ( Pset.mem (w,w') hb && Pset.mem (w',r) xw.sc)))
                             xo.actions ) )))) xw.rf)


let sc_accesses_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted", Leaf( sc_accesses_sc_reads_restricted)) ])) ]))


(*********************************************** *)


let sc_accesses_memory_model =  
({ consistent = sc_accesses_consistent_execution;
     relation_calculation = release_acquire_fenced_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val sc_accesses_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 11 - sc_fences, no consume *)
(*********************************************** *)


(*val sc_fenced_protocol : protocol_t*)
let sc_fenced_protocol ((xo,_,_):complete_execution)  = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire;Relaxed;Seq_cst]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release;Relaxed;Seq_cst]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Acq_rel;Acquire;Release;Relaxed;Seq_cst]))
       | Fence ( _, _, mo) -> ( Pset.mem mo
                                  (Pset.from_list Pervasives.compare
                                     [Release;Acquire;Relaxed;Seq_cst]))
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)


let sc_fenced_sc_fences_heeded (xo,xw,_) = ( 
  Pset.for_all
    (fun f -> Pset.for_all
                (fun f' -> Pset.for_all
                             (fun r -> Pset.for_all
                                         (fun w -> Pset.for_all
                                                     (fun w' -> not
                                                                  ( is_fence
                                                                    f &&
                                                                    ( 
                                                                    is_fence
                                                                    f' &&
                                                                    ( 
                                                                    (* fence restriction N3291 29.3p4 *)
                                                                    ( 
                                                                    Pset.mem
                                                                    (w,w')
                                                                    xw.mo &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (w',f)
                                                                    xw.sc &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f,r)
                                                                    xo.sb &&
                                                                    Pset.mem
                                                                    (w,r)
                                                                    xw.rf)) ) ||
                                                                    (* fence restriction N3291 29.3p5 *)
                                                                    (
                                                                    ( 
                                                                    Pset.mem
                                                                    (w,w')
                                                                    xw.mo &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (w',f)
                                                                    xo.sb &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f,r)
                                                                    xw.sc &&
                                                                    Pset.mem
                                                                    (w,r)
                                                                    xw.rf)) ) ||
                                                                    (* fence restriction N3291 29.3p6 *)
                                                                    (
                                                                    ( 
                                                                    Pset.mem
                                                                    (w,w')
                                                                    xw.mo &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (w',f)
                                                                    xo.sb &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f,f')
                                                                    xw.sc &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f',r)
                                                                    xo.sb &&
                                                                    Pset.mem
                                                                    (w,r)
                                                                    xw.rf))) ) ||
                                                                    (* SC fences impose mo N3291 29.3p7 *)
                                                                    (
                                                                    ( 
                                                                    Pset.mem
                                                                    (w',f)
                                                                    xo.sb &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f,f')
                                                                    xw.sc &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f',w)
                                                                    xo.sb &&
                                                                    Pset.mem
                                                                    (w,w')
                                                                    xw.mo)) ) ||
                                                                    (* N3291 29.3p7, w collapsed first write*)
                                                                    (
                                                                    ( 
                                                                    Pset.mem
                                                                    (w',f)
                                                                    xw.sc &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f,w)
                                                                    xo.sb &&
                                                                    Pset.mem
                                                                    (w,w')
                                                                    xw.mo) ) ||
                                                                    (* N3291 29.3p7, w collapsed second write*)
                                                                    ( 
                                                                    Pset.mem
                                                                    (w',f)
                                                                    xo.sb &&
                                                                    ( 
                                                                    Pset.mem
                                                                    (f,w)
                                                                    xw.sc &&
                                                                    Pset.mem
                                                                    (w,w')
                                                                    xw.mo) ))))) )) ))
                                                     xo.actions) xo.actions)
                             xo.actions) xo.actions) xo.actions)

let sc_fenced_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("sc_fenced_sc_fences_heeded", Leaf( sc_fenced_sc_fences_heeded));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted", Leaf( sc_accesses_sc_reads_restricted)) ])) ]))


(*********************************************** *)

let sc_fenced_memory_model =  
({ consistent = sc_fenced_consistent_execution;
     relation_calculation = release_acquire_fenced_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val sc_fenced_behaviour : opsem_t -> program -> program_behaviours*)




(*********************************************** *)
(* 12 - with consume *)
(*********************************************** *)


(*val with_consume_protocol : protocol_t*)
let with_consume_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire;Relaxed;Seq_cst;Consume]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release;Relaxed;Seq_cst]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Acq_rel;Acquire;Release;Relaxed;Seq_cst]))
       | Fence ( _, _, mo) -> ( Pset.mem mo
                                  (Pset.from_list Pervasives.compare
                                     [Release;Acquire;Relaxed;Seq_cst]))
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)

let with_consume_cad_set actions sb dd rf = ( tc ( Pset.union( Pset.inter rf  sb) dd ))

let with_consume_dob actions rf rs cad w a =    
(
    tid_of w <> tid_of a && 
  Pset.exists
    (fun w' -> Pset.exists
                 (fun r ->
                  is_consume r &&
                  ( Pset.mem (w,w') rs &&
                    ( Pset.mem (w',r) rf && ( Pset.mem (r,a) cad || (r = a) ))))
                 actions) actions)


let dependency_ordered_before actions rf rs cad a d = ( Pset.mem 
     a  actions && ( Pset.mem  d  actions &&
     ( Pset.exists
   (fun b -> is_release a &&
             ( is_consume b &&
               (( Pset.exists
                    (fun e -> Pset.mem (a,e) rs && Pset.mem (e,b) rf) 
                  actions) && ( Pset.mem (b,d) cad || (b = d) )))) actions )))


let with_consume_dob_set actions rf rs cad =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if dependency_ordered_before actions rf rs cad a b then
                     Pset.add (a,b) x2 else x2) actions x2) actions x2)


let compose r1 r2 =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun(w,x) x2 -> Pset.fold
                     (fun(y,z) x2 ->
                      if (x = y) then Pset.add (w,z) x2 else x2) r2 x2) 
 r1 x2)


let inter_thread_happens_before actions sb sw dob =    
(let r = ( Pset.union ( Pset.union sw dob) (compose sw sb)) in
      tc ( Pset.union r (compose sb r)))


let happens_before actions sb ithb = ( Pset.union sb ithb)


let with_consume_relations xo xw =    
(let hrs   = ( hypothetical_release_sequence_set xo.actions xo.lk xw.mo) in
    let rs    = ( release_sequence_set xo.actions xo.lk xw.mo) in
    let sw    = ( release_acquire_fenced_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs) in
    let cad   = ( with_consume_cad_set xo.actions xo.sb xo.dd xw.rf) in
    let dob   = ( with_consume_dob_set xo.actions xw.rf rs cad) in
    let ithb  = ( inter_thread_happens_before xo.actions xo.sb sw dob) in
    let hb    = ( happens_before xo.actions xo.sb ithb) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs);
      ("dob", dob);
      ("cad", cad) ])



let with_consume_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("sc_fenced_sc_fences_heeded", Leaf( sc_fenced_sc_fences_heeded));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted", Leaf( sc_accesses_sc_reads_restricted)) ])) ]))


(*********************************************** *)


let with_consume_memory_model =  
({ consistent = with_consume_consistent_execution;
     relation_calculation = with_consume_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val with_consume_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 13 - the standard model *)
(*********************************************** *)


let standard_vsses actions lk mo hb vse =  
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun r x2 -> Pset.fold
                  (fun v x2 -> Pset.fold
                                 (fun head x2 ->
                                  if
                                  is_at_atomic_location lk r &&
                                  ( Pset.mem (head,r) vse &&
                                    ( not
                                        ( Pset.exists
                                            (fun v' -> Pset.mem (v',r) vse &&
                                                       Pset.mem (head,v') mo)
                                            actions) &&
                                      ( v = head ||
                                        ( Pset.mem (head,v) mo &&
                                          ( not ( Pset.mem (r,v) hb) &&
                                            Pset.for_all
                                              (fun w -> ( not
                                                            ( Pset.mem
                                                                (head,w) 
                                                              mo &&
                                                              Pset.mem (w,v)
                                                                mo) ||
                                                          not
                                                            ( Pset.mem (r,w)
                                                                hb))) 
                                            actions) ) ))) then
                                    Pset.add (v,r) x2 else x2) actions 
                               x2) actions x2) actions x2)


let standard_relations xo xw =    
(let hrs   = ( hypothetical_release_sequence_set xo.actions xo.lk xw.mo) in
    let rs    = ( release_sequence_set xo.actions xo.lk xw.mo) in
    let sw    = ( release_acquire_fenced_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs) in
    let cad   = ( with_consume_cad_set xo.actions xo.sb xo.dd xw.rf) in
    let dob   = ( with_consume_dob_set xo.actions xw.rf rs cad) in
    let ithb  = ( inter_thread_happens_before xo.actions xo.sb sw dob) in
    let hb    = ( happens_before xo.actions xo.sb ithb) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    let vsses = ( standard_vsses xo.actions xo.lk xw.mo hb vse) in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("vsses", vsses);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs);
      ("dob", dob);
      ("cad", cad) ])


let standard_consistent_atomic_rf (xo,xw,_::_::_::("vsses",vsses)::_) = ( 
  Pset.for_all
    (fun (w,r) ->( not ( is_at_atomic_location xo.lk r && is_load r) ||
                   Pset.mem (w,r) vsses)) xw.rf)


let standard_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("sc_fenced_sc_fences_heeded", Leaf( sc_fenced_sc_fences_heeded));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("standard_consistent_atomic_rf",
                     Leaf( standard_consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted",
                     Leaf( sc_accesses_sc_reads_restricted)) ])) ]))


(*********************************************** *)


let standard_memory_model =  
({ consistent = standard_consistent_execution;
     relation_calculation = standard_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })

(*val standard_behaviour : opsem_t -> program -> program_behaviours*)





(*********************************************** *)
(* 14 - release acquire SC - memory_model simplified for programs without
consumes or relaxed *)
(*********************************************** *)

(* No longer applicable: If Nick was going to use this, I would want to strengthen up SC fences, and think some more about the SC fence absorbsion mismatch. I would also need to cut down hb to hthe SC portion that Nick discussed. *)

(*val release_acquire_SC_protocol : protocol_t*)
let release_acquire_SC_protocol ((xo,xw,rl):complete_execution) =    
(
    atomic_initialisation_first (xo,xw,rl) && ( Pset.is_empty (atomic_unsequenced_races (xo,xw,rl)) && 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire;Seq_cst]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release;Seq_cst]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Acq_rel;Seq_cst]))
       | Fence ( _, _, mo) -> ( Pset.mem mo
                                  (Pset.from_list Pervasives.compare
                                     [Seq_cst]))
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions))

(*********************************************** *)



let release_acquire_SC_memory_model =  
({ consistent = sc_fenced_consistent_execution;
     relation_calculation = release_acquire_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val release_acquire_SC_behaviour : opsem_t -> program -> program_behaviours*)


(*val release_acquire_SC_rf_behaviour : opsem_t -> program -> rf_program_behaviours*)


(*********************************************** *)
(* 15 - SC - memory_model simplified for programs without release, acquire,
consumes or relaxed *)
(*********************************************** *)


(*val SC_protocol : protocol_t*)
let sC_protocol ((xo,xw,rl):complete_execution) =    
(
    atomic_initialisation_first (xo,xw,rl) && ( Pset.is_empty (atomic_unsequenced_races (xo,xw,rl)) && 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Seq_cst]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Seq_cst]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Seq_cst]))
       | Fence ( _, _, mo) -> false
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions))

(*********************************************** *)



let sC_memory_model =  
({ consistent = sc_accesses_consistent_execution;
     relation_calculation = release_acquire_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val SC_behaviour : opsem_t -> program -> program_behaviours*)


(*********************************************** *)
(* 16 - tot - sequential consistency *)
(*********************************************** *)


(*val tot_protocol : protocol_t*)
let tot_protocol ((xo,xw,rl):complete_execution) =    
(( true (* Something to stop rf hb cycles *) ) &&
    (
    atomic_initialisation_first (xo,xw,rl) && ( Pset.is_empty (atomic_unsequenced_races (xo,xw,rl)) && 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> true
       | Unlock ( _, _, _) -> true
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Seq_cst]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Seq_cst]))
       | RMW ( _, _, mo, _, _, _) -> ( Pset.mem mo
                                         (Pset.from_list Pervasives.compare
                                            [Seq_cst]))
       | Fence ( _, _, mo) -> false
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)))


(* How closely do I model hb in this model? I don't necessarily want to require tot to have finite prefixes, because I don't have that for hb, do I have to? I don't think so. Things have cahnged somewhat since I last thought about that. Now I know that atomics and locks are never unordered by sb, for instance. *)

let tot_relations xo xw =    
(let sw    = ( release_acquire_synchronizes_with_set
                  xo.actions xo.sb xo.asw xw.rf xw.tot) in
    let hb    = ( no_consume_hb xo.sb sw) in
    let vse   = ( visible_side_effect_set xo.actions xw.tot) in
    [ ("empty",Pset.from_list Pervasives.compare []);
      ("vse", vse);
    ])


let tot_consistent_rf (xo,xw,_::("vse",vse)::_) = ( 
  Pset.for_all (fun (w,r) -> Pset.mem (w,r) vse) xw.rf)

let tot_consistent_locks (xo,xw,_) =
    ( Pset.for_all
   (fun (a,c) ->
    ( not
        (
        is_successful_lock a &&
        ( is_successful_lock c && (loc_of a = loc_of c))) ||
      ( Pset.exists
          (fun b -> (loc_of a = loc_of b) &&
                    ( is_unlock b &&
                      ( Pset.mem (a,b) xw.tot && Pset.mem (b,c) xw.tot)))
          xo.actions))) xw.tot)


let tot_conistent_tot (xo,xw,_) =    
(
    relation_over xo.actions xw.tot &&
    (
    trans xw.tot &&
    (
    irrefl xw.tot &&
    (
    total xo.actions xw.tot && ( Pset.subset 
    xo.sb  xw.tot && Pset.subset 
    xo.asw  xw.tot)))))


let tot_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("tot_conistent_tot", Leaf( tot_conistent_tot));
         ("tot_consistent_locks", Leaf( tot_consistent_locks));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("tot_consistent_rf", Leaf( tot_consistent_rf))
                ])
         )
       ]))



let tot_bad_mutexes (xo,xw,_) =  
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 ->
    if
    let lo = (let x2 =(Pset.from_list Pervasives.compare []) in
              Pset.fold
                (fun a x2 -> Pset.fold
                               (fun b x2 ->
                                if
                                ( Pset.mem (a,b) xw.tot) &&
                                ((loc_of a = loc_of b) &&
                                 is_at_mutex_location xo.lk a) then
                                  Pset.add (a,b) x2 else x2) xo.actions 
                             x2) xo.actions x2) in
    not (locks_only_good_mutex_use xo.actions xo.lk xo.sb lo a) then
      Pset.add a x2 else x2) xo.actions x2)


let tot_data_races (xo,xw,_) =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if not (a = b) &&
                      ((loc_of a = loc_of b) &&
                       ((is_write a || is_write b) &&
                        ((tid_of a <> tid_of b) &&
                         ( not (is_atomic_action a && is_atomic_action b) &&
                           not
                             ( Pset.exists
                                 (fun c -> ( Pset.mem (a,c) xw.tot) &&
                                           ( Pset.mem (c,b) xw.tot))
                                 xo.actions))))) then Pset.add (a,b) x2 else
                     x2) xo.actions x2) xo.actions x2)



let tot_undefined_behaviour =  
([ Two( ("unsequenced_races", unsequenced_races));
    Two( ("data_races", data_races));
    One( ("indeterminate_reads", indeterminate_reads));
    One( ("tot_bad_mutexes", tot_bad_mutexes)) ])



(*********************************************** *)




let tot_memory_model =  
({ consistent = tot_consistent_execution;
     relation_calculation = tot_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = false;
           sc_flag  = false;
           lo_flag  = false;
           ao_flag  = false;
           tot_flag = true; }
  })


(*val tot_behaviour : opsem_t -> program -> program_behaviours*)

(*val tot_rf_behaviour : opsem_t -> program -> rf_program_behaviours*)


(***********************)
(* - 16 - Meta-theory  *)
(***********************)

(*val thm0 : bool*)

(*val thm1 : bool*)

(*val thm2 : bool*)

(*val thm3 : bool*)

(*val thm4 : bool*)

(*val thm6 : bool*)

(*val thm7 : bool*)

(*val thm8 : bool*)

(*val thm9 : bool*)

(*val thm10 : bool*)

(*val thm5 : bool*)

(*val thm11 : bool*)

(*val thm12 : bool*)

(*val bigthm : bool*)



(*********************************************** *)
(* 17 - release acquire, no locks - memory_model simplified for programs without sc,
consumes, relaxed or locks *)
(*********************************************** *)


(*val release_acquire_no_locks_protocol : protocol_t*)
let release_acquire_no_locks_protocol ((xo,_,_):complete_execution) = ( 
  Pset.for_all
    (fun a ->
     (match a with
           | Lock ( _, _, _, _) -> false
       | Unlock ( _, _, _) -> false
       | Load ( _, _, mo, _, _) -> ( Pset.mem mo
                                       (Pset.from_list Pervasives.compare
                                          [NA;Acquire]))
       | Store ( _, _, mo, _, _) -> ( Pset.mem mo
                                        (Pset.from_list Pervasives.compare
                                           [NA;Release]))
       | RMW ( _, _, mo, _, _, _) -> mo = Acq_rel
       | Fence ( _, _, _) -> false
       | Blocked_rmw ( _, _, _) -> true
     )) xo.actions)


let release_acquire_no_locks_synchronizes_with actions sb asw rf a b =  
((tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* rel/acq sync *)
    ( is_release a && ( is_acquire b && Pset.mem  (a,b)  rf) )
  ))

let release_acquire_no_locks_synchronizes_with_set actions sb asw rf =    
(let x2 =(Pset.from_list Pervasives.compare []) in  Pset.fold
   (fun a x2 -> Pset.fold
                  (fun b x2 ->
                   if
                   release_acquire_no_locks_synchronizes_with actions sb asw
                     rf a b then Pset.add (a,b) x2 else x2) actions x2)
   actions x2)

let release_acquire_no_locks_relations xo xw =    
(let sw    = ( release_acquire_no_locks_synchronizes_with_set
                  xo.actions xo.sb xo.asw xw.rf) in
    let hb    = ( no_consume_hb xo.sb sw) in
    let vse   = ( visible_side_effect_set xo.actions hb) in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw) ])


let sc_lo_empty (_,xw,_) = ( Pset.is_empty xw.sc && Pset.is_empty xw.lo)


let release_acquire_no_locks_consistent_execution =  
(
  Node( [ ("assumptions", Leaf( assumptions));
         ("sc_lo_empty", Leaf( sc_empty));
         ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_mo", Leaf( consistent_mo));
         ("consistent_hb", Leaf( consistent_hb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity)) ])) ]))


(*********************************************** *)

let release_acquire_no_locks_undefined_behaviour =  
([ Two( ("unsequenced_races", unsequenced_races));
    Two( ("data_races", data_races));
    One( ("indeterminate_reads", indeterminate_reads)); ])



let release_acquire_no_locks_memory_model =  
({ consistent = release_acquire_no_locks_consistent_execution;
     relation_calculation = release_acquire_no_locks_relations;
     undefined = release_acquire_no_locks_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = true;
           ao_flag  = false;
           tot_flag = false }
  })


(*val release_acquire_no_locks_behaviour : opsem_t -> program -> program_behaviours*)



