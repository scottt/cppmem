(*Generated by Lem from ../axiomatic/ntc/operational/opsem_conversion.lem.*)
open Nat_num

open Sum

type 'a set = 'a Pset.set

open Opsem

(*val increase_registers_expression: num -> int_exp -> int_exp*)
let rec increase_registers_expression i exp =  
 ((match exp with 
  | ConstI( _) -> exp
  | Var( reg) -> Var( ( Nat_num.(+)reg i))
  | Plus( exp1, exp2) -> Plus( (increase_registers_expression i exp1), (increase_registers_expression i exp2))
  ))

(*val increase_registers_statement: num -> statement -> statement*)
let increase_registers_statement i statement =  
 ((match statement with 
  | Load( mo, reg, var) -> Load( mo, ( Nat_num.(+)reg i), var)
  | Store( mo, var, exp) -> Store( mo, var, (increase_registers_expression i exp))
  | Assert( _) -> statement
  | CreateThread( _) -> statement
  | JoinThread( _) -> statement
  ))

(*val increase_registers: num -> program -> program*)
let increase_registers i program =  
 (let convert_1 = (fun (statement, node) -> (increase_registers_statement i statement, node)) in
  let convert_2 = (fun x -> Pset.map compare convert_1 x) in
  let new_edges = ( Pmap.map convert_2 program.edges) in
  {program with edges = new_edges; })
  
  
(*val increase_nodenames_statement: num -> statement -> statement*)
let increase_nodenames_statement i statement =  
 ((match statement with 
  | Load( _, _, _) -> statement
  | Store( _, _, _) -> statement
  | Assert( _) -> statement
  | CreateThread( node) -> CreateThread( ( Nat_num.(+)node i))
  | JoinThread( node) -> JoinThread( ( Nat_num.(+)node i))
  ))
  
(*val increase_nodenames_aux: num -> list (node * set (statement * node)) -> Pmap.map node (set (statement * node))*)
let rec increase_nodenames_aux i l = 
 ((match l with 
 | [] -> (Pmap.empty Pervasives.compare)
 | (key, item)::t -> let new_item = ( Pset.map compare (fun (statement, node) -> (increase_nodenames_statement i statement, Nat_num.(+)node i)) item) in Pmap.add ( Nat_num.(+)key i) new_item (increase_nodenames_aux i t)
 ))
 
(*val increase_nodenames: num -> program -> program*)
let increase_nodenames i program =  
 ({program with start_node = Nat_num.(+)program.start_node i;
                 end_node = Nat_num.(+)program.end_node i;
                 edges = increase_nodenames_aux i ( Pmap.bindings program.edges);
  })
  
(*val replace_nodename_node: num -> num -> num -> num*)
let replace_nodename_node old replacement node =  
 (if node = old then replacement else node)
  
(*val replace_nodename_statement: num -> num -> statement -> statement*)
let replace_nodename_statement old replacement statement =  
 ((match statement with 
  | Load( _, _, _) -> statement
  | Store( _, _, _) -> statement
  | Assert( _) -> statement
  | CreateThread( node) -> CreateThread( (replace_nodename_node old replacement node))
  | JoinThread( node) -> JoinThread( (replace_nodename_node old replacement node))
  ))
  
(*val replace_nodename_aux: num -> num -> list (node * set (statement * node)) -> Pmap.map node (set (statement * node))*)
let rec replace_nodename_aux old replacement l = 
 ((match l with 
 | [] -> (Pmap.empty Pervasives.compare)
 | (key, item)::t -> let f = (fun (statement, node) -> (replace_nodename_statement old replacement statement, replace_nodename_node old replacement node)) in
                     let new_item = ( Pset.map compare f item) in Pmap.add (replace_nodename_node old replacement key) new_item (replace_nodename_aux old replacement t)
 ))
  
(*val replace_nodename: num -> num -> program -> program*)
let replace_nodename old replacement program =  
 ({program with start_node = replace_nodename_node old replacement program.start_node;
                 end_node = replace_nodename_node old replacement program.end_node;
                 edges = replace_nodename_aux old replacement ( Pmap.bindings program.edges);
  })
     
type program_aux = 
{ program: program;
   max_node: num;
   max_register: num
}

(*val lift: forall 'a. ('a -> 'a -> 'a) -> option 'a -> option 'a -> option 'a*)
let lift f left right =  
 ((match left with
  | None -> (match right with
            | None -> None
            | Some( _) -> right
            )
  | Some( left2) -> (match right with
                          | None -> left
                          | Some( right2) -> Some( (f left2 right2))
                          )
  ))

(*val compose_sequential_aux: program_aux -> program_aux -> program_aux*)
let compose_sequential_aux first second =  
 (let shifted_second = ( increase_nodenames first.max_node (increase_registers first.max_register second.program)) in
  let merged_second = ( replace_nodename shifted_second.start_node first.program.end_node shifted_second) in
  let new_program = ({ start_node = first.program.start_node;
                       end_node = merged_second.end_node;
                       edges = ( Pmap.concat first.program.edges merged_second.edges); }) in
  { program = new_program;
     max_node = ( Nat_num.(+)first.max_node second.max_node);
     max_register = ( Nat_num.(+)first.max_register second.max_register);
  })

(*val compose_sequential: option program_aux -> option program_aux -> option program_aux*)
let compose_sequential = ( lift compose_sequential_aux)

(*val compose_parallel_aux: program_aux -> program_aux -> program_aux*)
let compose_parallel_aux first second =  
 (let new_start_node = 1 in
  let new_end_node = ( Nat_num.(+) ( Nat_num.(+)first.max_node second.max_node) 2) in
  let shifted_first = ( increase_nodenames 1 first.program) in
  let shifted_second = ( increase_nodenames ( Nat_num.(+)first.max_node 1) (increase_registers first.max_register second.program)) in
  let new_edges_1 = ( Pmap.concat shifted_first.edges shifted_second.edges) in
  let new_edges_2 = ( Pmap.add new_start_node (
  Pset.from_list Pervasives.compare
    [ (CreateThread( shifted_second.start_node), shifted_first.start_node)]) new_edges_1) in
  let new_edges_3 = ( Pmap.add shifted_first.end_node (
  Pset.from_list Pervasives.compare
    [ (JoinThread( shifted_second.end_node), new_end_node)]) new_edges_2) in  
  let new_program = ({ start_node = new_start_node;
                       end_node = new_end_node;
                       edges = new_edges_3; }) in
  { program = new_program;
     max_node = ( Nat_num.(+) ( Nat_num.(+)first.max_node second.max_node) 2);
     max_register = ( Nat_num.(+)first.max_register second.max_register);
  })

(*val compose_parallel: option program_aux -> option program_aux -> option program_aux*)
let compose_parallel = ( lift compose_parallel_aux)

(*val empty_program: program_aux*)
let empty_program =  
 ({program = {start_node = 1; end_node = 1; edges = (Pmap.empty Pervasives.compare); };
    max_node = 1;
    max_register = 0;
  })

(* The program_aux parameter is the program that loads the registers that are used in the expression.
   We do not use compose_sequential to compose them, since the registers of the expressions would be shifted. *)
(*val create_store: option program_aux -> Cmm.memory_order -> variable -> int_exp -> program_aux*)
let create_store program_option mo var exp =  
(let program_aux = ((match program_option with
                     | None -> empty_program
                     | Some( x) -> x
                     )) in
  let intermediate_node = (program_aux.program.end_node) in
  let end_node = ( Nat_num.(+)program_aux.max_node 1) in
  let statement = ( Store( mo, var, exp)) in
  let edges = ( Pmap.add intermediate_node 
  (Pset.from_list Pervasives.compare [(statement, end_node)]) program_aux.program.edges) in
  let program = ({start_node = program_aux.program.start_node;
                  end_node = end_node;
                  edges = edges; }) in
  { program = program;
     max_node = ( Nat_num.(+)program_aux.max_node 1);
     max_register = program_aux.max_register })
  
(*val create_load: Cmm.memory_order -> variable -> (program_aux * int_exp)*)
let create_load mo var =  
(let register = 1 in
  let statement = ( Load( mo, register, var)) in
  let edges = ( Pmap.add 1 
  (Pset.from_list Pervasives.compare [(statement, 2)]) (Pmap.empty Pervasives.compare)) in
  let program = ({start_node = 1; end_node = 2; edges = edges }) in
  ({ program = program; max_node = 2; max_register = 1 }, Var( register)))
